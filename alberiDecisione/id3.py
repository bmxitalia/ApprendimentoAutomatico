# -*- coding: utf-8 -*-
"""ID3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13O4zrEt2EG_1_J7zvdZDgksUIQn3kl3R
"""

import numpy as np
from math import log
import copy
import pandas as pd
from anytree import Node, RenderTree


S = [
    ["Sunny", "Hot", "High", "Weak", "No"],
    ["Sunny", "Hot", "High", "Strong", "No"],
    ["Overcast", "Hot", "High", "Weak", "Yes"],
    ["Rain", "Mild", "High", "Weak", "Yes"],
    ["Rain", "Cool", "Normal", "Weak", "Yes"],
    ["Rain", "Cool", "Normal", "Strong", "No"],
    ["Overcast", "Cool", "Normal", "Strong", "Yes"],
    ["Sunny", "Mild", "High", "Weak", "No"],
    ["Sunny", "Cool", "Normal", "Weak", "Yes"],
    ["Rain","Mild","Normal","Weak", "Yes"],
    ["Sunny","Mild","Normal","Strong", "Yes"],
    ["Overcast","Mild","High","Strong", "Yes"],
    ["Overcast","Hot","Normal","Weak", "Yes"],
    ["Rain","Mild","High","Strong", "No"]
]


A = ["Outlook", "Temperature", "Humidity", "Wind"]
AA = ["Outlook", "Temperature", "Humidity", "Wind"]


# Calcolo l'entropia (grado di impurità)
#  S: dataset

def entropy(S):
    classes = {}

    if len(S) == 0:
        return 0

    # estraggo tutte le possibili classi e conto quante instance con quella classe
    for es in S:
        if es[4] not in classes:
            classes[es[4]] = 1
        else:
            classes[es[4]] += 1

    # calcolo l'entropia
    entropy = 0.0
    for c in classes:
        pc = classes[c] / len(S)
        entropy += pc * log(pc, 2)

    return -entropy


def gain(S, A, a):
    ent = entropy(S)
    labels = {}
    index = AA.index(a)

    for es in S:
        if es[index] not in labels:
            labels[es[index]] = 1
        else:
            labels[es[index]] += 1

    totalEntropy = 0.0
    for attr in labels:
        n = getRowByAttribute(S, index, attr)
        e = entropy(n) * len(n)/len(S)
        totalEntropy += e

    return ent - totalEntropy


def maxGain(S, A):
    max = -1000
    maxAttr = ""

    for attr in A:
        tmp = gain(S, A, attr)

        if tmp > max:
            max = tmp
            maxAttr = attr

    return maxAttr, max

def getRowByAttribute(S, column, a):
    rows = []

    for es in S:
        if es[column] == a:
            rows.append(es)

    return rows



# funzione che verifica se gli esempi nell'insieme passato sono tutti della
# stessa classe: ritorna l'etichetta della classe se gli esempi in S sono tutti
# della stessa classe oppure "none" altrimenti

def checkExamples(S):
    if not S:  # controllo lista vuota
        return "none"
    else:
        clas = S[0][4]
        for i in range(1, len(S)):
            if S[i][4] != clas:
                return "none"
        return clas


# funzione che ritorna la classe di maggioranza in S.
# se la lista è vuota ritorna none

def bestClass(S):
    if not S:
        return "none"
    else:
        max = -1000
        label = ""
        classes = {}
        for i in range(len(S)):  # conteggio del numero di esempi delle varie classi
            if S[i][4] not in classes:
                classes[S[i][4]] = 1
            else:
                classes[S[i][4]] += 1
        for j in classes:
            if classes[j] > max:
                max = classes[j]
                label = j
        return label


# funzione che restituisce i possibili valori che l'attributo a assume nel
# dataset
def valuesNumber(a, A):
    values = []
    index = AA.index(a)
    for i in range(len(S)):
        if S[i][index] not in values:
            values.append(S[i][index])
    return values


# funzione che restituisce l'insieme degli attributi dopo aver rimosso a

# functional way
def remove(a, A):
    C = copy.deepcopy(A)
    C.remove(a)
    return C

# funzione che dato un attributo a e un valore, restituisce il sottoinsieme di S
# dove a ha il valore passato

def sub(a, S, v, A):
    rlist = []
    index = AA.index(a)
    for i in range(len(S)):
        if S[i][index] == v:
            rlist.append(S[i])
    return rlist


# Algoritmo ID3
# S: esempi del dataset
# A: insieme di attributi

def ID3(S, A, parent):
    c = checkExamples(S)  # controllo classe esempi
    if c != "none":
        return Node(c, parent=parent)

    if not A:  # controllo A vuoto
        label = bestClass(S)
        return Node(label, parent=parent)

    # a = attributo ottimo in A -> funzione da fare
    a, gain = maxGain(S, A)

    # a = 0
    values = valuesNumber(a, A) # possibli valori che a può assumere
    n = Node(a, parent=parent, values=values)

    AA = copy.deepcopy(A)
    newAttrs = remove(a, A)

    for i in range(len(values)):
        ID3(sub(a, S, values[i], AA), newAttrs, n)  # rimane da capire come costruire l'albero ricorsivamente



# MAIN
papa = Node("root")
ID3(S, A, papa)
for pre, fill, node in RenderTree(papa):
  print("%s%s" % (pre, node.name))



